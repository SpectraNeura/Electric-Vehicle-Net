# -*- coding: utf-8 -*-
"""전기차_가격예측.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/156_Drq58ZDTg-NwlYKyhF7bwv9F-GUek

## **개요**
[배경]
안녕하세요 데이커 여러분 :)

전기차 가격 예측 해커톤: 데이터로 EV를 읽다!에 오신 것을 환영합니다!

전기차 가격 예측은 빠르게 성장하는 전기차 시장에서 소비자와 제조사 모두에게 중요한 가치를 제공합니다.

정확한 가격 예측은 시장 경쟁력 분석, 소비자 구매 의사 결정 지원, 그리고 생산 및 유통 최적화에 기여할 수 있습니다.

이번 해커톤에서 전기차의 다양한 데이터를 바탕으로 가격을 예측하는 AI 알고리즘을 개발하는 것을 목표로 합니다.

여러분의 창의적인 아이디어와 데이터 분석 역량을 통해, 전기차 시장의 미래를 만들어 보세요!

[주제]
전기차와 관련된 데이터를 활용하여 전기차 가격을 예측하는 AI 알고리즘 개발

### **1. 리더보드**
평가 산식 : RMSE
Public Score: 전체 테스트 데이터 중 사전 샘플링된 30%
Private Score: 전체 테스트 데이터 100%

### ***데이터***
* 제조사
* 모델
* 차량상태
* 베터리용량
* 구동방식
* 주행거리
* 보증기간
* 사고이력
* 연식
* 가격
"""

import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import lightgbm as lgb
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error

from google.colab import drive
drive.mount('/content/drive')

# /content/drive/MyDrive/개인파일/공부/DACON/전기차/data/test.csv
# /content/drive/MyDrive/개인파일/공부/DACON/전기차/data/train.
# data read

car_train_df = pd.read_csv('/content/drive/MyDrive/개인파일/공부/DACON/전기차/data/train.csv')
car_test_df = pd.read_csv('/content/drive/MyDrive/개인파일/공부/DACON/전기차/data/test.csv')
car_df = pd.concat([car_train_df, car_test_df], ignore_index=True)
car_df.to_csv('car_merged_file.csv', index=False)
car_df.head()

# total 8343
car_df.info()

# null : 3015
car_df.isnull().sum()

car_df.describe()

df = pd.DataFrame(car_df)
# 칼럼 고유값 개수 확인
unique_values = {col: df[col].unique().tolist() for col in df.columns}
for col, values in unique_values.items():
    print(f"column '{col}': {values}")

"""### **베터리 용량 결측치 조사**

"""

# 제조사, 모델별 배터리 용량 정리
battery_capacity_summary = car_df.groupby(['제조사', '모델'])['배터리용량'].agg(['mean', 'median', 'count']).reset_index()
print(battery_capacity_summary)

# 평균값 넣기, 중앙값 넣기, 근사치 넣기

mean_value = car_df['배터리용량'].mean()
median_value = car_df['배터리용량'].median()
min_value = car_df['배터리용량'].min()
max_value = car_df['배터리용량'].max()

print(f"평균: {mean_value}")
print(f"중앙값: {median_value}")
print(f"최소값: {min_value}")
print(f"최대값: {max_value}")
# 도메인 지식을 활용한 제조사, 년도별
#IQR 계산, 왜도 계산등을 해야함 정확히 하면
# 베터리 용량은 제조사별 특성에

"""### **베터리용량 결측치 채우기**"""

# 1. 중앙값으로 채우기
car_df_median = car_df.copy()
median_val = car_df_median['배터리용량'].median()
car_df_median['배터리용량'] = car_df_median['배터리용량'].fillna(median_val)

# 2. 평균값으로 채우기
car_df_mean = car_df.copy()
mean_val = car_df_mean['배터리용량'].mean()
car_df_mean['배터리용량'] = car_df_mean['배터리용량'].fillna(mean_val)

# 3. 근사치(보간법 사용)로 채우기
car_df_approx = car_df.copy()
car_df_approx['배터리용량'] = car_df_approx['배터리용량'].interpolate()

# 각 방식의 결과를 확인 (예시로 앞부분 5행 출력)
print("중앙값으로 채운 결과:")
print(car_df_median['배터리용량'].head())

print("\n평균값으로 채운 결과:")
print(car_df_mean['배터리용량'].head())

print("\n보간법(근사치)으로 채운 결과:")
print(car_df_approx['배터리용량'].head())

# 랜덤 포레스트
car_df_notnull = car_df[car_df['배터리용량'].notnull()].copy()
car_df_null = car_df[car_df['배터리용량'].isnull()].copy()

# feature 선택(의미있는 것들)
features = ['주행거리(km)', '보증기간(년)', '연식(년)', '가격(백만원)']

# 학습 데이터 구성
X_train = car_df_notnull[features]
y_train = car_df_notnull['배터리용량']

# 결측치가 있는 데이터의 특성 추출
X_test = car_df_null[features]

# Random Forest 모델 생성 및 학습
rf = RandomForestRegressor(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)

# 결측치 예측
predicted_values = rf.predict(X_test)

# 예측한 값으로 원본 데이터의 결측치 채우기
car_df_random_forest = df.copy()
car_df_random_forest.loc[car_df_random_forest['배터리용량'].isnull(), '배터리용량'] = predicted_values

# 채워진 결과 일부 확인
print("Random Forest로 채운 배터리용량 결측치 예시:")
print(car_df_random_forest.loc[df['배터리용량'].isnull(), ['배터리용량']])

"""### **병합된 파일 나누기**"""

split_index = len(car_train_df)  # 첫 번째 파일의 행

# Random Forest

car_train_df_split_random = car_df_random_forest.iloc[:split_index]
car_test_df_split_random = car_df_random_forest.iloc[split_index:]

# 나눠진 파일 저장하기-random
car_train_df_split_random.to_csv('car_train_split_random.csv', index=False)
car_test_df_split_random.to_csv('car_test_split_random.csv', index=False)

random_car_df = pd.read_csv('car_train_split_random.csv')

# median
car_train_df_split_median = car_df_median.iloc[:split_index]
car_test_df_split_median = car_df_median.iloc[split_index:]

# 나눠진 파일 저장하기-random
car_train_df_split_median.to_csv('car_train_split_median.csv', index=False)
car_test_df_split_median.to_csv('car_test_split_median.csv', index=False)

median_car_df = pd.read_csv('car_train_split_median.csv')

# mean
car_train_df_split_mean = car_df_mean.iloc[:split_index]
car_test_df_split_mean = car_df_mean.iloc[split_index:]

# 나눠진 파일 저장하기-random
car_train_df_split_mean.to_csv('car_train_split_mean.csv', index=False)
car_test_df_split_mean.to_csv('car_test_split_mean.csv', index=False)

mean_car_df = pd.read_csv('car_train_split_mean.csv')

# approx
car_train_df_split_approx = car_df_approx.iloc[:split_index]
car_test_df_split_approx = car_df_approx.iloc[split_index:]

# 나눠진 파일 저장하기-approx
car_train_df_split_approx.to_csv('car_train_split_approx.csv', index=False)
car_test_df_split_approx.to_csv('car_test_split_approx.csv', index=False)

approx_car_df = pd.read_csv('car_train_split_approx.csv')

"""### **결과 Test**"""

from sklearn.metrics import root_mean_squared_error as rmse

def evaluate_rmse(df, method_name):
    df.columns = df.columns.str.strip()

    # 범주형 변수 인코딩
    categorical_columns = ['제조사', '모델', '차량상태', '구동방식', '사고이력']
    df_encoded = pd.get_dummies(df, columns=categorical_columns, drop_first=True)

    # 예측에 사용할 피처는 ID와 타깃(가격)을 제외한 모든 컬럼으로 구성합니다.
    features = [col for col in df_encoded.columns if col not in ['ID', '가격(백만원)']]
    target = '가격(백만원)'

    # 학습/테스트 데이터 분리
    X_train, X_test, y_train, y_test = train_test_split(
        df_encoded[features], df_encoded[target], test_size=0.2, random_state=42
    )

    # Random Forest 모델 학습
    model = RandomForestRegressor(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)

    # 예측 및 RMSE 계산 (import한 rmse 함수 사용)
    predictions = model.predict(X_test)
    rmse_value = rmse(y_test, predictions)
    print(f"결측치 처리 방법: {method_name}, RMSE: {rmse_value:.4f}")
    return rmse_value


# =방법별 RMSE 평가 실행
evaluate_rmse(median_car_df, "중앙값 채우기")
evaluate_rmse(mean_car_df, "평균값 채우기")
evaluate_rmse(approx_car_df, "보간법 채우기")
evaluate_rmse(random_car_df, "Random Forest 채우기")

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split

train_df = pd.read_csv('/content/car_train_split_approx.csv')
train_df.columns = train_df.columns.str.strip()

categorical_columns = ['제조사', '모델', '차량상태', '구동방식', '사고이력']
train_encoded = pd.get_dummies(train_df, columns=categorical_columns, drop_first=True)

features = [col for col in train_encoded.columns if col not in ['ID', '가격(백만원)']]
target = '가격(백만원)'

X_train = train_encoded[features]
y_train = train_encoded[target]

model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)


test_df = pd.read_csv('/content/car_test_split_approx.csv')
test_df.columns = test_df.columns.str.strip()

test_encoded = pd.get_dummies(test_df, columns=categorical_columns, drop_first=True)
test_encoded = test_encoded.reindex(columns=features, fill_value=0)

predictions = model.predict(test_encoded)
if len(predictions) != len(test_df):
    print("경고: 예측 결과의 길이와 테스트 데이터의 길이가 다릅니다.")

test_df['가격(백만원)'] = predictions

test_df.to_csv('/content/car_test_with_predictions.csv', index=False)

submission = test_df[['ID', '가격(백만원)']]
submission.to_csv('submission_aprrox.csv', index=False)

print("예측값이 추가된 파일과 submission 파일이 생성")

